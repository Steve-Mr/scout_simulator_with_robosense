/// <reference types="node" />
import { EventEmitter } from 'events';
import Ultron = require('ultron');
import ActionClient from './ActionClient';
import { SimpleGoalState, SimpleClientGoalState } from './ClientStates';
import type ClientGoalHandle from './ClientGoalHandle';
import { RosTime } from '../lib/time/Time';
import type { ActionClientInterfaceOptions } from '../lib/ActionClientInterface';
import { ActionMsgs } from '../types/Message';
declare type ActiveCb = () => void;
declare type DoneCb<R> = (state: SimpleGoalState, result: R) => void;
declare type FeedbackCb<F> = (feedback: F) => void;
export default class SimpleActionClient<G, F, R> extends EventEmitter {
    _ac: ActionClient<G, F, R>;
    _simpleState: SimpleGoalState;
    _goalHandle: ClientGoalHandle<G, F, R>;
    _ultron: Ultron;
    _activeCb: ActiveCb;
    _doneCb: DoneCb<R>;
    _feedbackCb: FeedbackCb<F>;
    _shutdown: boolean;
    constructor(options: ActionClientInterfaceOptions);
    shutdown(): Promise<void>;
    waitForServer(timeout: number): Promise<boolean>;
    isServerConnected(): boolean;
    sendGoal(goal: G, doneCb?: DoneCb<R>, activeCb?: ActiveCb, feedbackCb?: FeedbackCb<F>): void;
    sendGoalAndWait(goal: G, execTimeout: RosTime, preemptTimeout: RosTime): Promise<SimpleClientGoalState>;
    waitForResult(timeout: RosTime): Promise<boolean>;
    _waitForResult(timeoutTime?: RosTime): Promise<boolean>;
    getResult(): R;
    getState(): SimpleClientGoalState;
    cancelAllGoals(): void;
    cancelGoalsAtAndBeforeTime(stamp: RosTime): void;
    cancelGoal(): void;
    stopTrackingGoal(): void;
    _handleTransition(): void;
    _handleFeedback(feedback: ActionMsgs.ActionFeedback<F>): void;
    _setSimpleState(newState: SimpleGoalState): void;
}
export {};
